name: CI Pipeline - Minikube Deployment

on:
  push:
    branches: [main, dev, feature/*]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (dev, staging, prod)"
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Lint and validate stage
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
        
      - name: Validate YAML files
        run: |
          echo "Validating YAML files..."
          # Basic YAML syntax validation using Python
          python3 -c "
          import yaml
          import sys
          import os

          def validate_yaml(file_path):
              # Skip Helm template files as they contain template syntax
              if '/templates/' in file_path:
                  print(f'‚è≠Ô∏è {file_path} - Skipped (Helm template)')
                  return True

              try:
                  with open(file_path, 'r') as f:
                      yaml.safe_load(f)
                  print(f'‚úÖ {file_path} - Valid YAML')
                  return True
              except Exception as e:
                  print(f'‚ùå {file_path} - Invalid YAML: {e}')
                  return False

          valid = True
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith(('.yml', '.yaml')):
                      file_path = os.path.join(root, file)
                      if not validate_yaml(file_path):
                          valid = False

          if not valid:
              sys.exit(1)
          "
          
      - name: Validate Helm charts
        run: |
          echo "Validating Helm charts..."
          # Lint with default values.yaml
          helm lint ./k8s-jobs || exit 1
          # Lint with environment-specific values
          for env in dev staging prod beta; do
            if [ -f "environments/$env/values.yaml" ]; then
              echo "Linting with environments/$env/values.yaml"
              helm lint ./k8s-jobs -f "environments/$env/values.yaml" || exit 1
            fi
          done
          
      - name: Check file structure
        run: |
          echo "Checking required files exist..."
          test -f "k8s-jobs/Chart.yaml" || exit 1
          test -f "k8s-jobs/templates/semgrep-job.yaml" || exit 1
          test -f "environments/dev/values.yaml" || exit 1
          echo "‚úÖ All required files present"

  # Build and test stage
  build-test:
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
          
      - name: Validate values files
        run: |
          echo "Validating values files..."
          # Only validate dev environment values file for now
          # staging/prod have token placeholders that need secrets
          if [ -f "environments/dev/values.yaml" ]; then
            echo "Validating environments/dev/values.yaml"
            helm template test ./k8s-jobs -f "environments/dev/values.yaml" --dry-run > /dev/null || exit 1
            echo "‚úÖ dev values file valid"
          fi
          
      - name: Validate Kubernetes manifests
        run: |
          echo "Validating Kubernetes manifests..."
          # Generate manifests and validate YAML structure without connecting to cluster
          helm template ./k8s-jobs -f environments/dev/values.yaml > /tmp/manifests.yaml

          # Validate YAML syntax
          python3 -c "
          import yaml
          import sys

          try:
              with open('/tmp/manifests.yaml', 'r') as f:
                  docs = list(yaml.safe_load_all(f))
              print(f'‚úÖ Generated {len([d for d in docs if d])} valid Kubernetes manifests')

              # Basic validation - check for required fields
              for doc in docs:
                  if doc and 'kind' in doc:
                      if 'metadata' not in doc or 'name' not in doc['metadata']:
                          print(f'‚ùå Missing required metadata.name in {doc.get(\"kind\", \"Unknown\")}')
                          sys.exit(1)
                      print(f'‚úÖ {doc[\"kind\"]}: {doc[\"metadata\"][\"name\"]}')
          except Exception as e:
              print(f'‚ùå Manifest validation failed: {e}')
              sys.exit(1)
          "
          echo "‚úÖ Kubernetes manifests valid"

  # Deploy to Minikube stage
  deploy-minikube:
    runs-on: ubuntu-latest
    needs: [lint, build-test]
    # No conditions - always run (for debugging)
    env:
      ENV: ${{ github.event.inputs.environment || 'dev' }}
      NAMESPACE: semgrep-${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Install Minikube
        run: |
          echo "üì¶ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          minikube version

      - name: Start Minikube
        run: |
          echo "üöÄ Starting Minikube cluster..."
          minikube start --cpus=4 --memory=8192 --driver=docker || echo "Minikube already running"
          minikube status
          
      - name: Configure kubectl context
        run: |
          kubectl config use-context minikube
          kubectl cluster-info

      - name: Create namespace
        run: |
          echo "üì¶ Creating namespace: ${{ env.NAMESPACE }}"
          kubectl get ns ${{ env.NAMESPACE }} || kubectl create ns ${{ env.NAMESPACE }}
          
      - name: Set Semgrep Token
        id: set-token
        run: |
          if [ "${{ env.ENV }}" == "dev" ]; then
            echo "Using dev token from values.yaml"
            echo "token_override=" >> $GITHUB_OUTPUT
          elif [ "${{ env.ENV }}" == "staging" ]; then
            echo "token_override=--set semgrep.token=${{ secrets.SEMGREP_TOKEN_STAGING }}" >> $GITHUB_OUTPUT
          elif [ "${{ env.ENV }}" == "prod" ]; then
            echo "token_override=--set semgrep.token=${{ secrets.SEMGREP_TOKEN_PROD }}" >> $GITHUB_OUTPUT
          fi
          
      - name: Deploy to Minikube
        run: |
          echo "üöÄ Deploying to Minikube (${{ env.ENV }} environment)..."
          helm upgrade --install semgrep-job ./k8s-jobs \
            -f environments/${{ env.ENV }}/values.yaml \
            ${{ steps.set-token.outputs.token_override }} \
            --set environment=${{ env.ENV }} \
            --set github.repository=${{ github.repository }} \
            -n ${{ env.NAMESPACE }} \
            --wait --timeout=10m
            
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          kubectl get all -n ${{ env.NAMESPACE }}
          kubectl get jobs -n ${{ env.NAMESPACE }}
          
      - name: Wait for Job Completion
        run: |
          echo "‚è≥ Waiting for Semgrep job to complete..."
          kubectl wait --for=condition=complete job/semgrep-scan-once \
            -n ${{ env.NAMESPACE }} \
            --timeout=600s || echo "Job may still be running"
            
      - name: View deployment logs
        run: |
          echo "üìã === DEPLOYMENT STATUS ==="
          kubectl get jobs -n ${{ env.NAMESPACE }}
          echo ""
          echo "üìã === SEMGREP LOGS ==="
          kubectl logs job/semgrep-scan-once -n ${{ env.NAMESPACE }} --all-containers=true || echo "No logs available yet"
          
      - name: Health check
        run: |
          echo "üè• Performing health check..."
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "‚úÖ Deployment health check completed"

      - name: Cleanup completed jobs (dev only)
        if: env.ENV == 'dev'
        run: |
          echo "üßπ Cleaning up completed jobs in dev environment..."
          kubectl delete job semgrep-scan-once -n ${{ env.NAMESPACE }} --ignore-not-found=true || true
          echo "‚úÖ Cleanup completed"


  # Notification stage
  notify:
    runs-on: ubuntu-latest
    needs: [lint, build-test, deploy-minikube]
    if: always()
    steps:
      - name: Pipeline status
        run: |
          echo "=== CI Pipeline Status ==="
          echo "Lint: ${{ needs.lint.result }}"
          echo "Build-Test: ${{ needs.build-test.result }}"
          echo "Deploy: ${{ needs.deploy-minikube.result }}"
          echo ""

          # Check if core stages (lint and build-test) passed
          if [ "${{ needs.lint.result }}" == "success" ] && [ "${{ needs.build-test.result }}" == "success" ]; then
            if [ "${{ needs.deploy-minikube.result }}" == "success" ]; then
              echo "‚úÖ CI Pipeline completed successfully with deployment!"
              echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
              echo "Deployment: Minikube"
            elif [ "${{ needs.deploy-minikube.result }}" == "skipped" ]; then
              echo "‚úÖ CI Pipeline completed successfully!"
              echo "Note: Deployment was skipped (likely due to PR or branch restrictions)"
            else
              echo "‚ö†Ô∏è CI Pipeline validation passed, but deployment failed!"
              echo "Check the deployment logs for details"
              exit 1
            fi
          else
            echo "‚ùå CI Pipeline failed!"
            echo "Check the logs for details"
            exit 1
          fi