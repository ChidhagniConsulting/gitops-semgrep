name: CI Pipeline - Minikube Deployment

on:
  push:
    branches: [main, dev, feature/*]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (dev, staging, prod)"
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Lint and validate stage
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
        
      - name: Validate YAML files
        run: |
          echo "Validating YAML files..."
          # Use helm template to validate all YAML files
          for file in $(find . -name "*.yml" -o -name "*.yaml"); do
            echo "Validating $file"
            if [[ "$file" == *"values.yaml" ]]; then
              # For values files, try to template with helm
              helm template test ./k8s-jobs -f "$file" --dry-run > /dev/null 2>&1 || echo "Warning: $file may have issues"
            else
              # For other YAML files, basic syntax check
              kubectl apply --dry-run=client -f "$file" > /dev/null 2>&1 || echo "Warning: $file may have issues"
            fi
          done
          
      - name: Validate Helm charts
        run: |
          echo "Validating Helm charts..."
          # Lint with default values.yaml
          helm lint ./k8s-jobs || exit 1
          # Lint with environment-specific values
          for env in dev staging prod; do
            if [ -f "environments/$env/values.yaml" ]; then
              echo "Linting with environments/$env/values.yaml"
              helm lint ./k8s-jobs -f "environments/$env/values.yaml" || exit 1
            fi
          done
          
      - name: Check file structure
        run: |
          echo "Checking required files exist..."
          test -f "k8s-jobs/Chart.yaml" || exit 1
          test -f "k8s-jobs/templates/semgrep-job.yaml" || exit 1
          test -f "environments/dev/values.yaml" || exit 1
          echo "‚úÖ All required files present"

  # Build and test stage
  build-test:
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
          
      - name: Validate values files
        run: |
          echo "Validating values files..."
          for env in dev staging prod; do
            if [ -f "environments/$env/values.yaml" ]; then
              echo "Validating environments/$env/values.yaml"
              helm template test ./k8s-jobs -f "environments/$env/values.yaml" --dry-run > /dev/null || exit 1
              echo "‚úÖ $env values file valid"
            fi
          done
          
      - name: Validate Kubernetes manifests
        run: |
          echo "Validating Kubernetes manifests..."
          helm template ./k8s-jobs -f environments/dev/values.yaml | kubectl apply --dry-run=client -f -

  # Deploy to Minikube stage
  deploy-minikube:
    runs-on: self-hosted
    needs: [lint, build-test]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    env:
      ENV: ${{ github.event.inputs.environment || 'dev' }}
      NAMESPACE: semgrep-${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
          
      - name: Start Minikube
        run: |
          echo "üöÄ Starting Minikube cluster..."
          minikube start --cpus=4 --memory=8192 --driver=docker || echo "Minikube already running"
          minikube status
          
      - name: Configure kubectl context
        run: |
          kubectl config use-context minikube
          kubectl cluster-info
          
      - name: Create namespace
        run: |
          echo "üì¶ Creating namespace: ${{ env.NAMESPACE }}"
          kubectl get ns ${{ env.NAMESPACE }} || kubectl create ns ${{ env.NAMESPACE }}
          
      - name: Set Semgrep Token
        id: set-token
        run: |
          if [ "${{ env.ENV }}" == "dev" ]; then
            echo "Using dev token from values.yaml"
            echo "token_override=" >> $GITHUB_OUTPUT
          elif [ "${{ env.ENV }}" == "staging" ]; then
            echo "token_override=--set semgrep.token=${{ secrets.SEMGREP_TOKEN_STAGING }}" >> $GITHUB_OUTPUT
          elif [ "${{ env.ENV }}" == "prod" ]; then
            echo "token_override=--set semgrep.token=${{ secrets.SEMGREP_TOKEN_PROD }}" >> $GITHUB_OUTPUT
          fi
          
      - name: Deploy to Minikube
        run: |
          echo "üöÄ Deploying to Minikube (${{ env.ENV }} environment)..."
          helm upgrade --install semgrep-job ./k8s-jobs \
            -f environments/${{ env.ENV }}/values.yaml \
            ${{ steps.set-token.outputs.token_override }} \
            --set environment=${{ env.ENV }} \
            --set github.repository=${{ github.repository }} \
            -n ${{ env.NAMESPACE }} \
            --wait --timeout=10m
            
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          kubectl get all -n ${{ env.NAMESPACE }}
          kubectl get jobs -n ${{ env.NAMESPACE }}
          
      - name: Wait for Job Completion
        run: |
          echo "‚è≥ Waiting for Semgrep job to complete..."
          kubectl wait --for=condition=complete job/semgrep-scan-once \
            -n ${{ env.NAMESPACE }} \
            --timeout=600s || echo "Job may still be running"
            
      - name: View deployment logs
        run: |
          echo "üìã === DEPLOYMENT STATUS ==="
          kubectl get jobs -n ${{ env.NAMESPACE }}
          echo ""
          echo "üìã === SEMGREP LOGS ==="
          kubectl logs job/semgrep-scan-once -n ${{ env.NAMESPACE }} --all-containers=true || echo "No logs available yet"
          
      - name: Health check
        run: |
          echo "üè• Performing health check..."
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "‚úÖ Deployment health check completed"

  # Cleanup stage (optional)
  cleanup:
    runs-on: self-hosted
    needs: deploy-minikube
    if: always() && github.ref == 'refs/heads/dev'
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Cleanup dev resources
        run: |
          echo "üßπ Cleaning up dev resources..."
          kubectl delete job semgrep-scan-once -n semgrep-dev || true
          echo "‚úÖ Cleanup completed"

  # Notification stage
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-minikube, cleanup]
    if: always()
    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy-minikube.result }}" == "success" ]; then
            echo "‚úÖ CI Pipeline completed successfully!"
            echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
            echo "Deployment: Minikube"
          else
            echo "‚ùå CI Pipeline failed!"
            echo "Check the logs for details"
            exit 1
          fi 