name: Deploy Semgrep to Local Minikube

on:
  issues:
    types: [opened]

jobs:
  debug-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Debug Issue Information
        run: |
          echo "=== ISSUE DEBUG INFO ==="
          echo "Issue Title: '${{ github.event.issue.title }}'"
          echo "Issue Number: ${{ github.event.issue.number }}"
          echo "Issue Labels: ${{ toJson(github.event.issue.labels) }}"
          echo "Issue Body (first 500 chars):"
          echo '${{ github.event.issue.body }}' | head -c 500
          echo ""
          echo "=== CONDITION CHECKS ==="
          echo "Has 'semgrep' label: ${{ contains(github.event.issue.labels.*.name, 'semgrep') }}"
          echo "Has 'minikube' label: ${{ contains(github.event.issue.labels.*.name, 'minikube') }}"
          echo "Has 'deployment' label: ${{ contains(github.event.issue.labels.*.name, 'deployment') }}"
          echo "Body contains 'Deploy Semgrep to Local Minikube': ${{ contains(github.event.issue.body, 'Deploy Semgrep to Local Minikube') }}"
          echo "Body contains 'Environment': ${{ contains(github.event.issue.body, 'Environment') }}"
          echo "Body contains 'What to Scan': ${{ contains(github.event.issue.body, 'What to Scan') }}"
          echo "Body contains 'Deployment Options': ${{ contains(github.event.issue.body, 'Deployment Options') }}"

  generate-deployment:
    if: |
      contains(github.event.issue.labels.*.name, 'semgrep') ||
      contains(github.event.issue.labels.*.name, 'minikube') ||
      contains(github.event.issue.labels.*.name, 'deployment') ||
      contains(github.event.issue.body, 'Deploy Semgrep to Local Minikube') ||
      contains(github.event.issue.body, 'Environment') ||
      contains(github.event.issue.body, 'What to Scan') ||
      contains(github.event.issue.body, 'Deployment Options')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Parse Issue Form Data
        id: parse
        run: |
          echo "=== PARSING ISSUE BODY ==="
          echo "Issue body:"
          echo '${{ github.event.issue.body }}'
          echo "=========================="

          # Extract environment with better logic
          ENV=$(echo '${{ github.event.issue.body }}' | grep -i -A 3 "environment" | grep -E "(dev|beta|prod)" | head -1 | tr -d '[:space:]' || echo "")
          if [ -z "$ENV" ]; then
            # Fallback: look for environment anywhere in the body
            ENV=$(echo '${{ github.event.issue.body }}' | grep -E "(dev|beta|prod)" | head -1 | grep -oE "(dev|beta|prod)" || echo "dev")
          fi
          echo "Extracted environment: '$ENV'"
          echo "environment=$ENV" >> $GITHUB_OUTPUT

          # Extract scan target
          SCAN_TARGET=$(echo '${{ github.event.issue.body }}' | grep -i -A 3 "what to scan" | tail -1 | sed 's/^[[:space:]]*//' || echo "All rules")
          if [ -z "$SCAN_TARGET" ] || [ "$SCAN_TARGET" = "_No response_" ]; then
            SCAN_TARGET="All rules (Frontend + Backend + Shared)"
          fi
          echo "Extracted scan target: '$SCAN_TARGET'"
          echo "scan_target=$SCAN_TARGET" >> $GITHUB_OUTPUT

          # Extract Semgrep token
          TOKEN=$(echo '${{ github.event.issue.body }}' | grep -i -A 3 "semgrep token" | tail -1 | sed 's/^[[:space:]]*//' || echo "")
          if [ "$TOKEN" != "_No response_" ] && [ -n "$TOKEN" ] && [ "$TOKEN" != "semgrep_dummy_token_1234567890abcdef1234567890abcdef" ]; then
            echo "has_token=true" >> $GITHUB_OUTPUT
            echo "token=$TOKEN" >> $GITHUB_OUTPUT
            echo "Token found: ***provided***"
          else
            echo "has_token=false" >> $GITHUB_OUTPUT
            echo "No valid token found, using default"
          fi

          # Check deployment options
          if echo '${{ github.event.issue.body }}' | grep -q "Include cleanup commands"; then
            echo "include_cleanup=true" >> $GITHUB_OUTPUT
          else
            echo "include_cleanup=false" >> $GITHUB_OUTPUT
          fi

          if echo '${{ github.event.issue.body }}' | grep -q "Show logs after deployment"; then
            echo "show_logs=true" >> $GITHUB_OUTPUT
          else
            echo "show_logs=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Semgrep Rules Configuration
        id: rules
        run: |
          SCAN_TARGET="${{ steps.parse.outputs.scan_target }}"

          if [[ "$SCAN_TARGET" == *"Frontend"* ]]; then
            echo "rules_path=./rules/frontend/" >> $GITHUB_OUTPUT
            echo "rules_description=Frontend (JavaScript/TypeScript)" >> $GITHUB_OUTPUT
          elif [[ "$SCAN_TARGET" == *"Backend"* ]]; then
            echo "rules_path=./rules/backend/" >> $GITHUB_OUTPUT
            echo "rules_description=Backend (Java)" >> $GITHUB_OUTPUT
          elif [[ "$SCAN_TARGET" == *"Shared"* ]]; then
            echo "rules_path=./rules/shared/" >> $GITHUB_OUTPUT
            echo "rules_description=Shared (Common security)" >> $GITHUB_OUTPUT
          elif [[ "$SCAN_TARGET" == *"All rules"* ]]; then
            echo "rules_path=./rules/" >> $GITHUB_OUTPUT
            echo "rules_description=All rules (Frontend + Backend + Shared)" >> $GITHUB_OUTPUT
          else
            echo "rules_path=./rules/" >> $GITHUB_OUTPUT
            echo "rules_description=All rules (default)" >> $GITHUB_OUTPUT
          fi

      - name: Create Custom Values File
        run: |
          ENV="${{ steps.parse.outputs.environment }}"
          echo "Using environment: '$ENV'"

          # Validate environment
          if [ -z "$ENV" ] || [ "$ENV" = "" ]; then
            echo "Environment is empty, defaulting to 'dev'"
            ENV="dev"
          fi

          # Check if environment file exists
          if [ ! -f "./environments/$ENV/values.yaml" ]; then
            echo "Environment file not found: ./environments/$ENV/values.yaml"
            echo "Available environments:"
            ls -la ./environments/
            echo "Defaulting to dev environment"
            ENV="dev"
          fi

          echo "Final environment: '$ENV'"
          cp "./environments/$ENV/values.yaml" "./custom-values.yaml"

          # Update rules path
          sed -i "s|configPath: .*|configPath: ${{ steps.rules.outputs.rules_path }}|" ./custom-values.yaml

          # Update token if provided
          if [ "${{ steps.parse.outputs.has_token }}" == "true" ]; then
            sed -i "s|token: .*|token: \"${{ steps.parse.outputs.token }}\"|" ./custom-values.yaml
          fi

          echo "Generated custom values file:"
          cat ./custom-values.yaml

      - name: Generate Deployment Script
        run: |
          cat > deploy-semgrep.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "ðŸš€ Deploying Semgrep to Local Minikube"
          echo "======================================="

          # Check if Minikube is running
          echo "ðŸ“‹ Checking Minikube status..."
          if ! minikube status > /dev/null 2>&1; then
            echo "âŒ Minikube is not running. Please start it first:"
            echo "   minikube start"
            exit 1
          fi
          echo "âœ… Minikube is running"

          # Check if Helm is installed
          if ! command -v helm &> /dev/null; then
            echo "âŒ Helm is not installed. Please install Helm first."
            exit 1
          fi
          echo "âœ… Helm is available"

          # Deploy Semgrep
          echo "ðŸš€ Deploying Semgrep job..."
          helm upgrade --install semgrep-scan ./k8s-jobs \
            --values ./custom-values.yaml \
            --wait \
            --timeout=300s

          echo "âœ… Deployment completed!"

          # Show status
          echo "ðŸ“Š Checking deployment status..."
          kubectl get jobs -l app=semgrep
          kubectl get pods -l app=semgrep

          EOF

          chmod +x deploy-semgrep.sh

      - name: Generate Monitoring Script
        if: steps.parse.outputs.show_logs == 'true'
        run: |
          cat > monitor-semgrep.sh << 'EOF'
          #!/bin/bash

          echo "ðŸ“Š Monitoring Semgrep Job"
          echo "========================"

          # Wait for job to start
          echo "â³ Waiting for job to start..."
          kubectl wait --for=condition=ready pod -l app=semgrep --timeout=60s

          # Follow logs
          echo "ðŸ“‹ Following job logs..."
          kubectl logs -f job/semgrep-scan

          # Show final status
          echo "ðŸ“Š Final job status:"
          kubectl get jobs -l app=semgrep
          kubectl describe job semgrep-scan

          EOF

          chmod +x monitor-semgrep.sh

      - name: Generate Cleanup Script
        if: steps.parse.outputs.include_cleanup == 'true'
        run: |
          cat > cleanup-semgrep.sh << 'EOF'
          #!/bin/bash

          echo "ðŸ§¹ Cleaning up Semgrep deployment"
          echo "================================="

          # Delete the Helm release
          helm uninstall semgrep-scan

          # Clean up any remaining resources
          kubectl delete jobs -l app=semgrep
          kubectl delete pods -l app=semgrep

          echo "âœ… Cleanup completed!"

          EOF

          chmod +x cleanup-semgrep.sh

      - name: Create Deployment Package
        run: |
          mkdir -p deployment-package
          cp -r k8s-jobs deployment-package/
          cp -r environments deployment-package/
          cp -r rules deployment-package/
          cp custom-values.yaml deployment-package/
          cp deploy-semgrep.sh deployment-package/
          [ -f monitor-semgrep.sh ] && cp monitor-semgrep.sh deployment-package/
          [ -f cleanup-semgrep.sh ] && cp cleanup-semgrep.sh deployment-package/

          # Create README
          cat > deployment-package/README.md << EOF
          # Semgrep Local Minikube Deployment

          ## Configuration
          - **Environment**: ${{ steps.parse.outputs.environment }}
          - **Scan Target**: ${{ steps.rules.outputs.rules_description }}
          - **Rules Path**: ${{ steps.rules.outputs.rules_path }}

          ## Quick Start

          1. **Deploy Semgrep**:
             \`\`\`bash
             ./deploy-semgrep.sh
             \`\`\`

          2. **Check Status**:
             \`\`\`bash
             kubectl get jobs,pods -l app=semgrep
             \`\`\`

          3. **View Results**:
             \`\`\`bash
             kubectl logs job/semgrep-scan
             \`\`\`

          EOF

          if [ -f monitor-semgrep.sh ]; then
            cat >> deployment-package/README.md << EOF
          4. **Monitor Logs** (real-time):
             \`\`\`bash
             ./monitor-semgrep.sh
             \`\`\`

          EOF
          fi

          if [ -f cleanup-semgrep.sh ]; then
            cat >> deployment-package/README.md << EOF
          5. **Cleanup** (when done):
             \`\`\`bash
             ./cleanup-semgrep.sh
             \`\`\`

          EOF
          fi

          cat >> deployment-package/README.md << EOF
          ## Manual Commands

          If you prefer to run commands manually:

          \`\`\`bash
          # Deploy
          helm upgrade --install semgrep-scan ./k8s-jobs --values ./custom-values.yaml

          # Check status
          kubectl get jobs,pods -l app=semgrep

          # View logs
          kubectl logs job/semgrep-scan

          # Cleanup
          helm uninstall semgrep-scan
          \`\`\`
          EOF

      - name: Upload Deployment Package
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-minikube-deployment
          path: deployment-package/
          retention-days: 30

      - name: Comment with Deployment Instructions
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentInfo = `
            ## ðŸš€ Semgrep Minikube Deployment Ready!

            **Configuration:**
            - **Environment**: ${{ steps.parse.outputs.environment }}
            - **Scan Target**: ${{ steps.rules.outputs.rules_description }}
            - **Rules Path**: ${{ steps.rules.outputs.rules_path }}

            ### ðŸ“¦ Deployment Package Created

            A complete deployment package has been generated and uploaded as an artifact. You can:

            1. **Download the artifact** from this workflow run
            2. **Extract it** to your local machine
            3. **Run the deployment script**

            ### ðŸš€ Quick Deployment

            After downloading and extracting the artifact:

            \`\`\`bash
            # Make sure Minikube is running
            minikube status

            # Deploy Semgrep
            ./deploy-semgrep.sh

            # Check results
            kubectl logs job/semgrep-scan
            \`\`\`

            ### ðŸ“‹ Manual Deployment

            If you prefer manual commands:

            \`\`\`bash
            # Clone this repository
            git clone https://github.com/${{ github.repository }}.git
            cd gitops-semgrep

            # Deploy with custom configuration
            helm upgrade --install semgrep-scan ./k8s-jobs \\
              --set environment=${{ steps.parse.outputs.environment }} \\
              --set semgrep.configPath=${{ steps.rules.outputs.rules_path }} \\
              --values ./environments/${{ steps.parse.outputs.environment }}/values.yaml

            # Monitor the job
            kubectl get jobs,pods -l app=semgrep
            kubectl logs -f job/semgrep-scan
            \`\`\`

            ${ steps.parse.outputs.include_cleanup === 'true' ? '### ðŸ§¹ Cleanup\n\nWhen you\'re done, run:\n```bash\n./cleanup-semgrep.sh\n```\n' : '' }

            ### ðŸ“Š Monitoring

            - **Job Status**: \`kubectl get jobs -l app=semgrep\`
            - **Pod Status**: \`kubectl get pods -l app=semgrep\`
            - **Logs**: \`kubectl logs job/semgrep-scan\`
            - **Detailed Info**: \`kubectl describe job semgrep-scan\`

            ---

            **Need help?** Check the README.md file in the deployment package for detailed instructions.
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: deploymentInfo
            })